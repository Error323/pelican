#===============================================================================
# subpackage.cmake
#
# Macros for handling sub-package creation
# 
# Sets: 
#   SUBPACKAGE_WORK_DIR: the work directory for sub-package module files.
#
#
# Defines the following public macros:
#   SUBPACKAGE: register a sub-package and set / get dependencies.
#   SUBPACKAGE_LIBRARY: Create the subpackage library.
#
#
# Defines the following utility macros:
#   SUBPACKAGE_GET_LIBS: Get the libraries required to link the specified 
#                        sub-package
#   SUBPACKAGE_GET_INCS: Get the includes required for the specified sub-package.
#
#
#===============================================================================

#
# Macro to register and set / get sub-package dependencies.
#
macro(SUBPACKAGE name)

    # Set the current sub-package name.
    set(subpackage_current "${name}")
    
    # Set the name of the sub-package file.
    set(subpackage_file "${SUBPACKAGE_WORK_DIR}/${name}.cmake")

    # Write guard in the sub-package file to prevent double loading of this file/
    file(WRITE ${subpackage_file}
        "# Sub-package: '${name}'\n"
        "#  This file is auto-generated by the build system - do not edit.\n"
        "if(subpackage_${name}_LIBS)\n"
        "   return()\n"
        "endif(subpackage_${name}_LIBS)\n\n"
    )

    # Process packages that the sub-package depends on.
    # --------------------------------------------------------------------------
    set(subpackage_${name}_DEPS ${ARGN})

    # If any dependencies exist.    
    if(subpackage_${name}_DEPS)
        # Reverse the list of dependencies.
        list(REVERSE subpackage_${name}_DEPS)
        # Add the list of dependencies to the sub-package file.
        file(APPEND ${subpackage_file}
            "set(subpackage_${name}_DEPS ${subpackage_${name}_DEPS})\n"
        )
    endif(subpackage_${name}_DEPS)
    
    # Export all include directories defined before this macro
    if(COMMAND GET_PROPERTY)
        get_property(includes DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY INCLUDE_DIRECTORIES)
    else(COMMAND GET_PROPERTY)
        # cmake 2.4 compatibility, just include everthing.
        set(includes ${CMAKE_INCLUDE_PATH})
    endif(COMMAND GET_PROPERTY)

    # Add the includes to the sub-package file.
    foreach(inc ${includes})
        file(APPEND ${subpackage_file} "include_directories(${inc})\n")
    endforeach(inc)

    # Add the package files of dependent sub-packages to the sub-package file.
    foreach(pack ${ARGN})
        file(APPEND ${subpackage_file} 
            "include(${SUBPACKAGE_WORK_DIR)/${pack}.cmake)\n")
    endforeach(pack)

    # Set the top level directory for includes.
    include_directories(${CMAKE_CURRENT_SOURCE_DIR})
    
    # Loop over the sub-package depenency list, loading their subpackage module
    # files to get the required librarys.
    foreach(dep ${subpackage_${name}_DEPS})
        # Load the sub-package file.
        include(${SUBPACKAGE_WORK_DIR}/${dep}.cmake)
        # Extract the required libraries setting ${SUBPACKAGE_LIBRARIES}.
        _SUBPACKAGE_GET_LIBS(${dep})        
    endforeach(dep)
    
    # Remove duplicates from sub-package libraries ?
    # TODO?

    # Create the install target for header files of the sub-package.
    #---------------------------------------------------------------------------
    file(GLOB public_headers RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "*.h")
    install(FILES ${public_headers} DESTINATION ${INCLUDE_INSTALL_DIR}/${name})
        
    # TODO: instead of writing to the subpackge file thoughout.
    # add what is needed at the very end or just set variables and delay 
    # this to another macro.

    file(WRITE ${subpackage_file} "#=====================================\n\n")

endmacro(SUBPACKAGE)



macro(SUBPACKAGE_LIBRARY name)

    # If the module / sub-package is defined (set by LIBRARY_MODULE_REQUIREMENTS)
    if(subpackage_current MATCHES "${name}")

        # Add target for the dynamic library.
        add_library("${name}" SHARED ${ARGN})

        # Add target for static library.        
        if(BUILD_STATIC)
            add_library("${name}_static" STATIC ${ARGN})
        endif(BUILD_STATIC)
        
        # Set properties for the library targets.
        set_target_properties("${name}" PROPERTIES CLEAN_DIRECT_OUTPUT 1)
        if(BUILD_STATIC)
            set_target_properties("${name}_static" PROPERTIES OUTPUT_NAME "${name}")
            set_target_properties("${name}_static" PROPERTIES PREFIX "lib")
            set_target_properties("${name}_static" PROPERTIES CLEAN_DIRECT_OUTPUT 1)
        endif(BUILD_STATIC)

        # If building a single package library link against the other library
        # modules. [[ needed? ]]
        if(BUILD_SINGLE_LIB)
            if(PROJECT_LIBRARIES)
                SUBPACKAGE_ADD_LIBRARIES("${PROJECT_LIBRARIES}")
            else(PROJECT_LIBRARIES)
                message(FATAL_ERROR "ERROR: No PROJECT_LIBRARIES set")
            endif(PROJECT_LIBRARIES)
        else(BUILD_SINGLE_LIB)
            SUBPACKAGE_ADD_LIBRARIES("${name}")
        endif(BUILD_SINGLE_LIB)

        _SUBPROJECT_OBJECT_FILES("${name}" "${name}_shared_objects")
        file(APPEND ${subpackage_file}
            "list(INSERT shared_libs 0 "${moduleName}")\n"
            "list(INSERT shared_objects 0 ${${name}_shared_objects})\n"
        )
        if(BUILD_STATIC)
            _SUBPROJECT_OBJECT_FILES("${name}_static" "${name}_static_objects")
            file(APPEND ${subpackage_file}
                "list(INSERT static_libs 0 "${name}_static")\n"
                "list(INSERT static_objects 0 ${${name}_static_objects})\n")
        endif(BUILD_STATIC)

    else(subpackage_current MATCHES "${name}")
        message(FATAL_ERROR "ERROR: SUBPACKAGE_LIBRARY for '${name}' "
            " specified outside of a SUBPACKAGE context")
    endif(subpackage_current MATCHES "${name}")

endmacro(SUBPACKAGE_LIBRARY)


#
# 
#
macro(SUBPACKAGE_ADD_LIBRARIES name)

    if(subpackage_current MATCHES ${name})
        list(INSERT SUBPACKAGE_LIBRARIES 0 ${ARGN})
        list(INSERT SUBPACKAGE_${SUBPACKAGE_CURRENT}_LIBS 0 ${ARGN})
        file(APPEND ${subpackage_file}
            "list(INSERT SUBPACKAGE_${subpackage_current}_LIBS 0 ${ARGN})\n")
    else(subpackage_current MATCHES ${name})
        message(FATAL_ERROR "SUBPACKAGE_ADD_LIBRARIES for '${name}' "
            "specified outside of a SUBPACKAGE context")
    endif(subpackage_current MATCHES ${name})
    
endmacro(SUBPACKAGE_ADD_LIBRARIES)



#
# Macro to register and set / get sub-package dependencies.
#
macro(USE_SUBPACKGES)

    # Process packages that the sub-package depends on.
    # --------------------------------------------------------------------------
    set(subpackage_${name}_DEPS ${ARGN})

    # If any dependencies exist.    
    if(subpackage_${name}_DEPS)
        # Reverse the list of dependencies.
        list(REVERSE subpackage_${name}_DEPS)
    endif(subpackage_${name}_DEPS)
    
    # Export all include directories defined before this macro
    if(COMMAND GET_PROPERTY)
        get_property(includes DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY INCLUDE_DIRECTORIES)
    else(COMMAND GET_PROPERTY)
        # cmake 2.4 compatibility, just include everthing.
        set(includes ${CMAKE_INCLUDE_PATH})
    endif(COMMAND GET_PROPERTY)

    # Set the top level directory for includes.
    include_directories(${CMAKE_CURRENT_SOURCE_DIR})
    
    # Loop over the sub-package depenency list, loading their subpackage module
    # files to get the required librarys.
    foreach(dep ${subpackage_${name}_DEPS})
        # Load the sub-package file.
        include(${SUBPACKAGE_WORK_DIR}/${dep}.cmake)
        # Extract the required libraries setting ${SUBPACKAGE_LIBRARIES}.
        _SUBPACKAGE_GET_LIBS(${dep})        
    endforeach(dep)
    
endmacro(USE_SUBPACKGES)




# ==============================================================================
# Private utility macros
# ==============================================================================

#
# private macro to generate the SUBPACKAGE_LIBRARIES variable
#
macro(_SUBPACKAGE_GET_LIBS name)
    if(NOT subpackage_${name}_added)
        foreach(pack ${SUBPACKAGE_${name}_DEPS})
            _SUBPACKAGE_GET_LIBS(${pack})
        endforeach(pack)
        if(SUBPACKAGE_${name}_LIBS)
            list(INSERT SUBPACKAGE_LIBRARIES 0 ${SUBPACKAGE_${name}_LIBS})
        endif(SUBPACKAGE_${name}_LIBS)
        set(subpackage_${name}_added TRUE)
    endif(NOT subpackage_${name}_added)
endmacro(_SUBPACKAGE_GET_LIBS)



macro(_SUBPROJECT_OBJECT_FILES target outputObjectFiles)
    # This hack inspired by the bug report : http://www.cmake.org/Bug/view.php?id=5155
    #
    # CMake generators are currently of 2 types: those which build single configurations, and those
    # which build multiple configurations. These 2 types use 2 different directory structures for where
    # they put their object files. The currently recommended way to deduce which type of generator
    # we're using, is to see if CMAKE_CONFIGURATION_TYPES is empty or not. If it's empty, then it's
    # single configuration. If it's non-empty, then it's multiple configuration, and contains a list of all
    # the configurations available. We're not interested in that list, only whether it's empty or non-empty.

    if(CMAKE_CONFIGURATION_TYPES)
        # We have a multiple configuration generator. Use this directory structure.
        #
        # Note that CMAKE_BUILD_TYPE has no value when Visual Studio .sln files are generated.
        # This is because on MSVC, no build type is actually selected at generation time. The MSVC
        # user typically selects her build type after opening the .sln file. CMAKE_CFG_INTDIR expands
        # to a Visual Studio macro that will contain the right value, once Visual Studio is opened and
        # a build type is selected.
        set(STATIC_OBJ_DIR ${CMAKE_CURRENT_BINARY_DIR}/${target}.dir/${CMAKE_CFG_INTDIR})
    else(CMAKE_CONFIGURATION_TYPES)
        # We have a single configuration generator. Use this directory structure:
        set(STATIC_OBJ_DIR ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_FILES_DIRECTORY}/${target}.dir)
    endif(CMAKE_CONFIGURATION_TYPES)

    # Now we know what directory the objects live in. Construct the actual list of objects:
    # from the sources. We cannot glob as these files do not exist yet
    get_property( target_sources TARGET ${target} PROPERTY SOURCES )
    
    foreach( sourcefile ${target_sources} )
        if(IS_ABSOLUTE ${sourcefile})
            # absolutes will appear in the top level object dir
            get_filename_component(source_name "${sourcefile}" NAME)
        else(IS_ABSOLUTE ${sourcefile})
            # relative will also be relative to the top level object dir
            set(source_name "${sourcefile}")
        endif(IS_ABSOLUTE ${sourcefile})
        list(APPEND ${outputObjectFiles} ${source_name}${CMAKE_C_OUTPUT_EXTENSION})
    endforeach( sourcefile )
    
    _ADD_DIR_PREFIX(${STATIC_OBJ_DIR}/ ${outputObjectFiles})
endmacro(_SUBPROJECT_OBJECT_FILES )



macro(_ADD_DIR_PREFIX prefix rootlist)
    set(outlist)
    foreach(root ${${rootlist}})
        if(IS_ABSOLUTE ${root})
            list(APPEND outlist ${root})
        else(IS_ABSOLUTE ${root})
            list(APPEND outlist ${prefix}${root})
        endif(IS_ABSOLUTE ${root})
    endforeach(root)
    set(${rootlist} ${outlist})
endmacro(_ADD_DIR_PREFIX)
