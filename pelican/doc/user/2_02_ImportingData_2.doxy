namespace pelican {

/**

\page importData_2 Importing Data II: The Server, Client and Data Adapters

\section importData_Server The Pelican Server

\todo Introduce the server - what it is used for.

\subsection importData_ServerChunkers Specifying Chunkers

The Pelican Server requires you to specify one or more chunkers
and associate these chunkers to one or more named data streams.

This is done via the PelicanServer::addStreamChunker() and
PelicanServer::addServiceChunker() methods. As the names suggest, the former
is used to associate chunkers with data streams that are to be treated as
stream data, and the latter for data that is to be treated as service data.


\section importData_UsingDataClients Data Clients

A data-client is an implementation of the AbstractDataClient interface,
which is the primary interface used by the processing pipeline for accessing
data when it needs it.

Pelican provides two different data-client implementations that you can
configure to your needs:
\li The PelicanServerClient connects to a Pelican server and so only
    requires an adapter (the chunker being in the server itself).
\li The DirectStreamDataClient connects directly to the incoming
data stream and so needs both an adapter and a chunker.

These clients can be used directly by specifying adapters and chunkers in the XML
configuration file. Alternatively you can inherit from these classes to set
your adapters and chunkers as appropriate using the class API. This latter
method is recommended as it allows you to provide an "official" data interface
for your application with customised configuration options and sensible default
settings, allowing ease of reuse by pipeline developers.

\subsection specifyDataClient Specifying the Data Client
The PelicanApplication needs to know which data client will be used
for importing data. You specify the class by calling the
PipelineApplication::setDataClient() method, supplying the name of the data
client's class as a string.

e.g. for the DirectDataClientExample below you would use
\code
PipelineApplication* app; // initialised application
app->setDataClient("DirectDataClientExample");
\endcode


\subsection dataClientAdapter Installing an Adapter into a DataClient
\subsubsection dataClientAdapter_XML XML configuration to install an Adapter
\subsubsection dataClientAdapter_API Using the API to install an Adapter

\subsection dataClientChunkers Installing Chunkers into the DirectStreamDataClient
\subsubsection connecting_dataClientDirect_XML XML configuration options to install a Chunker
\subsubsection connecting_dataClientDirect_API Inheriting from the DirectStreamDataClient
In the constructor of your DataClient call the \em addChunker()
method to attach your chunker to the named stream.

e.g.
\include DirectDataClientExample.h
\include DirectDataClientExample.cpp

In this example demonstrates how to attach two chunkers of the
same type to two differently named streams. The chunkers will be initialised
with the relevant XML chunk that corresponds to the chunker and has
the \em name parameter that corresponds to the final string passed to
\em addChunker.  By passing parameters through this config, you can setup
your chunker appropriately.



\todo Methods of using the direct stream and Pelican server client....

\subsection importData_PelicanServerClient Pelican Server Client

\subsection importData_DirectStreamClient Direct Stream Client

\todo Data Client Example (tutorial) - using pelican server.



\section importData_Adapters Adapters

<em>Adapters</em> are the final components of the data-import chain, and
provide a mechanism to convert chunks of raw binary data into the data
members of a Pelican data-blob (a specialised C++ container for holding data
used by the Pelican pipeline; see \ref importData_DataBlobs "below").
The most basic function of an adapter is to de-serialise chunks of data,
although re-ordering and re-factoring of the data to a form that is convenient
for subsequent pipeline processing may also be carried out.
Pelican currently provides support for two categories of adapters,
distinguished by the type of input data chunks they are expected to process:
these are stream data adapters and service data adapters, which operate on the
relevant \ref importData_DataTypes "data types".

Adapters can be configured, if required, using parameters specified in the XML
configuration file. An adapter must inherit either the AbstractStreamAdapter
or the AbstractServiceAdapter class interface, depending on its type.

\subsection importData_DataBlobs Data-Blobs

A Pelican <em>data-blob</em> is a well-structured representation of data that
has been arranged for easy, optimal processing: the output from an adapter is a
well-structured representation of the data held in a chunk, which is ready to
be processed by a pipeline. Data-blobs may contain arrays, blocks of memory
and/or other metadata, and should provide methods to interact with that data.
One of their main functions is to act as an interface between pipeline modules.

\subsection importData_tutorialDataBlob Tutorial Data-Blob

For the purpose of our tutorial, we need a type of DataBlob that can hold the
required time-series data in a chunk. This is implemented in the SignalData
data-blob, shown below, as a simple contiguous float array (a standard C++
vector). Public methods allow this array to be resized, and should be used to
obtain a pointer to the start of the data so that elements can be accessed
efficiently.

\include SignalData.h

The data-blob must be declared so that the Pelican framework knows of its
existence: use the PELICAN_DECLARE_DATABLOB macro in the header file to do this,
supplying the class name as the macro argument. Do not use quotes around the
name.

This concludes our description of the required SignalData data-blob.

\subsection importData_tutorialAdapter Tutorial Adapter

As a type of AbstractStreamAdapter, our SignalDataAdapter must convert the
data held in a chunk into a SignalData data-blob. The adapter must process the
chunk, removing all headers from the UDP packets it contains, and reinterpret
the contents of the data section as 32-bit floating-point numbers.

The C++ header file for our SignalDataAdapter is shown below:

\include SignalDataAdapter.h

The adapter must be declared so that the Pelican framework knows of its
existence: use the PELICAN_DECLARE_ADAPTER macro in the header file to do this,
supplying the class name as the macro argument. Do not use quotes around the
name.

As well as the constructor, we must implement the AbstractAdapter::deserialise()
method, which must deserialise the contents of the chunk into the required
data blob.

Here's the class implementation in the C++ source %file:

\include SignalDataAdapter.cpp

A reference to the XML configuration node for the adapter will be
automatically supplied to the constructor from the application's
\ref user_referenceConfiguration "configuration file": we then simply need to
extract the relevant configuration settings using methods on the supplied
ConfigNode object. The ConfigNode::getOption method returns a QString
containing the text in the required tagname and attribute. To illustrate what
is needed here, the adapter expects an XML snippet like this:

\verbatim
<SignalDataAdapter>
    <packet samples="256" />
</SignalDataAdapter>
\endverbatim

The contents of the string containing the number of samples per packet are
converted to an integer value using the QString::toInt() method, and
stored in a private class variable for later use.

The AbstractAdapter is aware of the data blob that must be filled, so in our
SignalDataAdapter::deserialise() routine, we must obtain a pointer to this
data blob by calling the AbstractAdapter::dataBlob() inherited method. The
chunk size is also available, and can be retrieved using the
AbstractAdapter::chunkSize() inherited method.

The remainder of the deserialise routine simply loops over the UDP packets in
the chunk, discarding the headers in each case, and reading the data sections
into the correct parts of the SignalData data-blob.

\note It is important, especially when the input device is a TCP socket,
to check that sufficient data is available before trying to read it. For this
reason we have included a call to QIODevice::waitForReadyRead() if there is not
enough data available on the device.

This concludes our description of the required SignalDataAdapter. The following
section shows how to process this data by creating a simple module and
inserting it into a processing pipeline.

\latexonly
\clearpage
\endlatexonly

*/

}
