/**
\page user_referenceAdapters Data Adapters

\section user_referenceAdapters_introduction Introduction

Adapters provide a mechanism to convert chunks of raw binary data into the data
members of a pelican data blob (a specialised C++ container class use for 
holding data used by the pelican pipeline).

The most basic functionality of an adapter is to de-serialise chunks of 
of data, although reordering and re-factoring of the data to a form that is
convenient for subsequent pipeline processing may also be carried out.

Pelican currently provides support for two categories of adapters distinguished
by the type of input data chunks they are expected to process, stream adapters 
and service adapters (<i>## TODO: ref. description of stream and service data...</i>):

\li <b>Stream Adapters:</b> De-serialise chunks of data classed as stream data.
Stream adapters allow for the de-serialisation method to be modified 
by service data registered to be associated to the stream data.
\li <b>Service Adapters:</b> De-serialise chunks of data classed as service data. 
The adaptation of data chunks classed as service data is not expected to change 
during an instance of running pelican.

Adapters plug into the pelican data clients and the de-serialise method
is called for each iteration of the pipeline that requires data of the type which
they adapt. In addition to calling the adapter \c deserialise() method the \c config()
method of the adapter base class is called setting the pointer to the data blob
which the adapter is to populate, the chunk size to be adapted as well as pointers
to any associated service data (for the case of stream adapters). This data
is therefore available to the \c deserialise() method though members of the base
class rather than explicitly though the interface of the de-serialise method.

\section user_referenceAdapters_overview Overview

(## TODO change title to something like 'Implementation steps'.)

To create a new adapter :

\li Inherit from either the \c AbstractStreamAdapter, or the
    \c AbstractServiceAdapter class.
\li In the derived class, implement the \c deserialise() method. This method
    is passed a pointer to an open \c QIODevice containing the serial chunk
    to be adapted. De-serialised data should be placed in the data blob pointer,
    \c _data, which is a protected member of the \c AbstractAdapter base class and 
    set automatically by the data client on request for remote data in a 
    pipeline to which adapter is providing de-serialised data blobs.
    \li The size of the chunk of data in the QIODevice (in bytes) as well as, for
        the case of stream adapters, associated service data blobs are available to
        the adapter by though data members of the base class, set by the data client
        _chunkSize and _serviceData.
\li Register their existence with the adapter factory.
    Use the \c PELICAN_DECLARE_ADAPTER() macro in the adapter's source
    (*.cpp) file to register the adapter, supplying the name of the adapter
    class as the macro argument. Do not use quotes around the name.
\li The data object being populated by the adapter, must be a pelican data blob
    (i.e. a class that inherits from \c DataBlob).
    There are a number of data blob types that are currently provided by the 
    pelican framework, so you may not need to create your own if these are suitable.

\section user_referenceAdapters_configuration Configuration

(## TODO: ref to configuration section)

All adapters must be supplied with a configuration node in their constructors. 
The configuration node resides in the adapters section of the configuration XML
file, and has a tag name the same as the adapter class name.

The configuration within the node is then left up to the details of the 
specific adapter but will need to contain all the information needed 
to de-serialise the chunk begin adapted.

\section user_referenceAdapters_example Example

The following example shows a stream adapter created to convert chunks of data 
containing sections of a stream of real floating point values into the example data
blob (## TODO: example data blob).

The XML configuration node is:

\verbatim
<AdapterExample>
    <samples number="512" bitsPerSample="8"/>
</AdapterExample>
\endverbatim

The class definition is:

\include AdapterExample.h

and the class implementation is:

\include AdapterExample.cpp

*/
